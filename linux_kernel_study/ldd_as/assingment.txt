	• Driver Basics
-------------
How is the dependency generated for modprobe & where is it stored?
		○ Depmod will generate the dependency list and it is stored in the depmod.dep file
	• How do we change the log level for printk?
		○ https://en.wikipedia.org/wiki/Printk
		○ KERN_EMERG, KERN_ALERT, KERN_CRIT, KERN_ERR, 
	• Integrate the first_driver.c into the Kernel build system.
		○ Changes need to be done with kbuild 


Character Drivers
-----------------
1. Register the basic character driver and verify the registration under /proc/devices.
2. Try dereferencing he user space buffer in read operation
3. Exchange the data with User space with copy_to_user() and copy_from_user()
4. Enhance the driver to send last character of previously written string.
   For example:
    echo -n "abcd" > /dev/abc
    cat /dev/abc (Should give 'd')
5. Write a driver to get & set the value of driver global variable using the ioctl.
6. Write a charac threads - one which adds the node, one which deletes the node, one which traverses the
list. Use read-write lock as synchronization mechanism
6. Modify above driver to use seq lock
7. Modify above driver to use rcu for the lists
Waiting/Blocking
----------------
1. Modify sched2.c to use the wait queue.
2. Enhance the above driver to have 2 minors & hence 2 device files. Process invoking read on each device file should be
   blocked on same wait queue, but different wake up condition. For instance, echo 'x' > /proc/wait should wake up the
   process which is waiting on first device file and echo 'y' > /proc/wait should wake up the process waiting on second
   device file. 
3. Create a character driver which blocte operation to
   unblock the read operation. Further to this, invoke read from multiple shells & try to wake them simultaneously.
4. Enhance the is waiting
Notifier Chains
---------------
1. Write a driver to publish the notifier chain & create another driver to subscribe to the  to add the tion on first
device file should print 'Read on first device file' and operation on second device file should print 'Read on second
device file.
7. Write a udev rule to auto-load/unload a driver module when pen driver is plugged-in/plugged-out respectively.
Module Parameters
-----------------
1. Write a driver to pass integer value as module parameter
2. Change the parameter value at runtime.
3. Enhance the driver to pass array of integers as module parameter
	https://stackoverflow.com/questions/10994576/passing-an-array-as-command-line-argument-for-linux-kernel-module
	https://www.linuxtopia.org/online_books/linux_kernel/linux_kernel_module_programming_2.6/x323.html
4. Enhance the driver to register the callback handler for parameters change
      https://stackoverflow.com/questions/34957016/signal-on-kernel-parameter-change
     

Synchronization
---------------
1. Use atomic_inc/atomic_dec to increment/decremenite spinlock
3. Write a driver to protect the global variable using seqlock. The example should hit the scenario where reader sees the
inconsistencies and had to retry.
4. Write a driver which uses list apis to add and delete the list items.
5. Modify above driver to have 3notifier chain. (Refer
drivers/usb/core/notify.c)
2. Write a driver to register for the usb notifier and print the messages when the d. Enhance the keyboard_notifier to include the support for character driver. The keys are buffered and sent to the user
space, when its requested
4. Enhance the above driver to add the support for i to set the keylogger buffer size using the module params.
6. Modify the driver further to use the kfifo to hold the keys & transfer the same to user space.

From <https://drive.google.com/drive/folders/1iwk4qIGQ5mAio2ot0-FYeNoa9i48Z6JP>ter driver



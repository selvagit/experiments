Synchronization
---------------
1. Use atomic_inc/atomic_dec to increment/decremenite spinlock
./Exercises/Slides/KernelProcessManagement.pdf:    CPU instructions that provide the atomic read-modify-
./Exercises/Slides/KernelProcessManagement.pdf:    Handy for manipulation of shared data atomically in
./Exercises/Slides/KernelProcessManagement.pdf:    Generic atomic operation interfaces include support for integer
./Exercises/Slides/KernelProcessManagement.pdf:    Integer operations operate on atomic_t & atomic64_t
./Exercises/Slides/KernelProcessManagement.pdf:    –   atomic_read(v)
./Exercises/Slides/KernelProcessManagement.pdf:    –   atomic_set(v, i)
./Exercises/Slides/KernelProcessManagement.pdf:    –   atomic_add(init i, atomic_t *v)
./Exercises/Slides/KernelProcessManagement.pdf:    –   atomic_sub(int i, atomic_t *v)
./Exercises/Slides/KernelProcessManagement.pdf:    –   atomic_inc(atomic_t *v)
./Exercises/Slides/KernelProcessManagement.pdf:    –   atomic_dec(atomic_t *v)
./Exercises/Slides/KernelProcessManagement.pdf:    –   bool atomic_sub_and_test(int i, atomic_t *v)
./Exercises/Slides/KernelProcessManagement.pdf:    –   bool atomic_dec_and_test(atomic_t *v)
./Exercises/Slides/KernelProcessManagement.pdf:    –   bool atomic_dec_and_test(atomic_t *v)
./Exercises/Slides/KernelProcessManagement.pdf:    RCU infrastructure in turn uses global atomic counters and
./Exercises/Slides/KernelProcessManagement.pdf:    – Making updates atomic would help solves this issue
./Exercises/Slides/KernelProcessManagement.pdf:    – The notifier chain is executed in interrupt or atomic context
https://github.com/Embetronicx/Tutorials/blob/master/Linux/Device_Driver/Atomic_variable/driver.c


3. Write a driver to protect the global variable using seqlock. The example should hit the scenario where reader sees the inconsistencies and had to retry.

./Exercises/Slides/KernelProcessManagement.pdf:    – void write_seqlock_irqrestore(seqlock_t *lock, long flags)
./Exercises/Slides/KernelProcessManagement.pdf:    – unsigned int read_seqbegin(seqlock_t *lock);
./Exercises/Slides/KernelProcessManagement.pdf:           Begins the read & returns the sequence number
./Exercises/Slides/KernelProcessManagement.pdf:    – unsigned int read_seqbegin_irqsave(seqlock_t
./Exercises/Slides/KernelProcessManagement.pdf:    – int read_seqretry(seqlock_t *lock, unsigned int
./Exercises/Slides/KernelProcessManagement.pdf:      seq_no);
./Exercises/Slides/KernelProcessManagement.pdf:         Compare the sequence number with provided sequence
./Exercises/Slides/KernelProcessManagement.pdf:            – If the current sequence number is odd value or the current
./Exercises/Slides/KernelProcessManagement.pdf:             sequence number is not matching
./Exercises/Slides/KernelProcessManagement.pdf:    seqlock doesn’t./Exercises/Slides/KernelProcessManagement.pdf:    Consequences
./Exercises/Slides/KernelProcessManagement.pdf:    Stands for sequential lock
./Exercises/Slides/KernelProcessManagement.pdf:              How seqlock works?
./Exercises/Slides/KernelProcessManagement.pdf:    Maintains a sequence counter
./Exercises/Slides/KernelProcessManagement.pdf:    obtained and a sequence number is incremented
./Exercises/Slides/KernelProcessManagement.pdf:    Prior to & after reading the data, the sequence number
./Exercises/Slides/KernelProcessManagement.pdf:    #include <linux/seqlock.h>
./Exercises/Slides/KernelProcessManagement.pdf:    seqlock_t lock
./Exercises/Slides/KernelProcessManagement.pdf:    seqlock_init(seqlock_t *lock) (Initialization)
./Exercises/Slides/KernelProcessManagement.pdf:    – void write_seqlock(seqlock_t *lock) (Writing)
./Exercises/Slides/KernelProcessManagement.pdf:    – void write_seqlock_irq(seqlock_t *lock)
./Exercises/Slides/KernelProcessManagement.pdf:    – void write_seqlock_irqsave(seqlock_t *lock, long flags)
./Exercises/Slides/KernelProcessManagement.pdf:    – void write_sequnlock(seqlock_t *lock)
./Exercises/Slides/KernelProcessManagement.pdf:    – void write_sequnlock_irq(seqlock_t *lock)
./Exercises/Slides/KernelProcessManagement.pdf:    – void write_seqlock_irqrestore(seqlock_t *lock, long flags)
./Exercises/Slides/KernelProcessManagement.pdf:    – unsigned int read_seqbegin(seqlock_t *lock);
./Exercises/Slides/KernelProcessManagement.pdf:           Begins the read & returns the sequence number
./Exercises/Slides/KernelProcessManagement.pdf:    – unsigned int read_seqbegin_irqsave(seqlock_t
./Exercises/Slides/KernelProcessManagement.pdf:    – int read_seqretry(seqlock_t *lock, unsigned int
./Exercises/Slides/KernelProcessManagement.pdf:      seq_no);
./Exercises/Slides/KernelProcessManagement.pdf:         Compare the sequence number with provided sequence
./Exercises/Slides/KernelProcessManagement.pdf:            – If the current sequence number is odd value or the current
./Exercises/Slides/KernelProcessManagement.pdf:             sequence number is not matching
./Exercises/Slides/KernelProcessManagement.pdf:    seqlock doesn’t
./Exercises/Slides/ldd_intro.pdf:    Additionally, a initial 3 character sequence for Log Level
https://github.com/Embetronicx/Tutorials/blob/master/Linux/Device_Driver/Seqlock/driver.c

4. Write a driver which uses list apis to add and delete the list items.
https://www.kernel.org/doc/html/v4.19/core-api/kernel-api.html
https://github.com/Embetronicx/Tutorials/blob/master/Linux/Device_Driver/Linked_List/driver.c

5. Modify above driver to have 3 notifier chain. (Refer drivers/usb/core/notify.c)
./Exercises/Slides/KernelProcessManagement.pdf:    Uses notifier chains to inform asynchronous events or
./Exercises/Slides/KernelProcessManagement.pdf:    #include <linux/notifier.h>
./Exercises/Slides/KernelProcessManagement.pdf:    struct notifier_block {
./Exercises/Slides/KernelProcessManagement.pdf:    – int (* notifier_call)(struct notifier block *, unsigned
./Exercises/Slides/KernelProcessManagement.pdf:    – struct notifier_block *next;
./Exercises/Slides/KernelProcessManagement.pdf:    used to manage & traverse the notifier block list
./Exercises/Slides/KernelProcessManagement.pdf:    – The notifier chain is executed in interrupt or atomic context
./Exercises/Slides/KernelProcessManagement.pdf:    – Time critical events use this notifier
./Exercises/Slides/KernelProcessManagement.pdf:    – Eg: Keyboard notifier
./Exercises/Slides/KernelProcessManagement.pdf:    – Eg: usb notifier to inform devices being added
./Exercises/Slides/KernelProcessManagement.pdf:    – Typically, used in low level events such as CPU notifier to pass on
./Exercises/Slides/KernelProcessManagement.pdf:    Sleepable Read Copy Update (SRCU) notifiers
./Exercises/Slides/KernelProcessManagement.pdf:    – Run in process context, similar to the blocking notifier chain, but
https://www.opensourceforu.com/2009/01/the-crux-of-linux-notifier-chains/

2. Write a driver to register for the usb notifier and print the messages when the d. Enhance the keyboard_notifier to include the support for character driver. The keys are buffered and sent to the user space, when its requested
https://www.opensourceforu.com/2009/01/the-crux-of-linux-notifier-chains/
https://0xax.gitbooks.io/linux-insides/content/Concepts/linux-cpu-4.html

4. Enhance the above driver to add the support for i to set the keylogger buffer size using the module params.
https://github.com/jarun/spy/blob/master/spy.c
http://redgetan.cc/lets-write-a-kernel-keylogger/ --> last step to hide the module 

6. Modify the driver further to use the kfifo to hold the keys & transfer the same to user space.
./Exercises/ProcessMngmt/Kfifo/kfifo.c:#include <linux/kfifo.h>
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    printk(KERN_INFO "kfifo test start\n");
./Exercises/ProcessMngmt/Kfifo/kfifo.c:        kfifo_put(&test, i);
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    printk(KERN_INFO "fifo len: %u\n", kfifo_len(&test));
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    ret = kfifo_out(&test, buf, 2);
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    ret = kfifo_in(&test, buf, ret);
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    kfifo_skip(&test);
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    for (i = 20; kfifo_put(&test, i); i++)
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    printk(KERN_INFO "queue len: %u\n", kfifo_len(&test));
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    if (kfifo_peek(&test, &i))
./Exercises/ProcessMngmt/Kfifo/kfifo.c:    while (kfifo_get(&test, &i)) {
